First created a project and an app just like we did in the previous video which created existing files and we need to start editing them as per the requirements of our project.
```bash
arrangement 
 pollapp
    manage.py
    pollapp
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
    polls
        __init__.py
        admin.py
        apps.py
        models.py
        tests.py
        views.py
        urls.py - manually created
        migrations
            __init__.py
```
### views.py: 
This file contains the logic of our application. It receives requests and returns responses. This is a basic view to open this in browser we need to map this to a url right so now we go to urls.py and edit there

### The urls.py
 file should be created inside the polls itself

 üåê Browser Request (http://127.0.0.1:8000/blog/)
```bash 

        |
        v
+-------------------+
|   Project urls.py |
+-------------------+
   "blog/" ‚Üí send to myapp

        |
        v
+-----------------+
|   App urls.py   |   (inside myapp)
+-----------------+
   "" ‚Üí views.index
   "post/" ‚Üí views.post

        |
        v
+------------------+
|   Views (Python) |
+------------------+
   index() ‚Üí returns homepage
   post()  ‚Üí returns blog post

        |
        v
+------------------+
|   Response (HTML)|
+------------------+


# big picture

     User / Browser
        |
        v
+-------------------+
|  Project urls.py  |   <-- Main entry (decides which app handles request)
+-------------------+
        |
        v
+-------------------+
|    App urls.py    |   <-- Routes inside the app
+-------------------+
        |
        v
+-------------------+
|     views.py      |   <-- What to do for this request?
+-------------------+
   |            |
   |            v
   |    +-----------------+
   |    |    models.py    |  <-- Database (fetch/save data)
   |    +-----------------+
   |
   v
+-------------------+
|    templates/     |   <-- HTML files (UI shown to user)
+-------------------+
        |
        v
+-------------------+
|   Final Response  |   <-- Sent back to browser
+-------------------+
```
Now run python manage.py runserver we can now see the changes made on the browser when localhost:8000/polls is requested

Now everything is done for now so in the exisiting files few of them uses atleast one database table so lets create them before they try to use it so we need to migrate. we can just use the migrate command eitherwise

If we have provided any specific models data to create certain table then we need to make migrations command and then migrate
but migrate single also works if no modle provided.

#### Now lets make few tables for that we need to go to models.py

- The code we write in models.py not only used for the creation or updation or anything that is related to the db but also the django admin portal. so smae code is represented and the aliasing names in the code is seen on admin page not in db.
```bash
  python manage.py sqlmigrate polls 0001
```  
- This command shows the sql format of the code that we have written in models.py

   0001 is the migration file created inside migrations folder
-  Generally this is just used to check what the django is actually doing in the backend before migrate and make migrations commands. just for our own validations. And this is so better as we dont need to learn sql to create tables and all as it is only doing all the work for us.

Shell- there is something caled django shell which can be treated like a runtime interpreter for django, we can write our code and press enter and the result comes. 

  python manage.py shell

=> This command opens the shell
   from polls.models import Question, Choice
=> This imports the models that we have created
   q = Question(question_text="What's new?", pub_date="2024-06-01")
=> This creates an object of the Question class
   q.save()
=> This saves the object to the db
   q.id
=> This gives the id of the object created
   q.question_text
=> This gives the question text of the object created
   q.pub_date
=> This gives the pub date of the object created
   q.choice_set.all()
=> This gives all the choices related to the question object created 

Why we are actually using this is to test the code that we are writing. But here once the code is tested and working fine it still creates the db tables really. Now if we write the same code in models or views then also tables are created. so to avoid confusion we can clear the db generated by the shell through command
      Question.objects.all().delete() - for all objects 
      Question.objects.filter(question_text="Shell data").delete() - only if this is created by shell then only to remove it coz the command of delete doesnt know whether the data created by shell or view or other it just deletes everything.

=> We have observed the outputs in the shell right based on the command we typed. But the import or question words are actually taken from the models.py where we actually created the models/tables. the shell is pulling its code from there and also the o/p format too. If no specific format mentioned in the code to how the o/p should displayed then it shows the default format like Question object(1) but if we need human readable format then we need to provide a __str__ method
    def __str__(self):
         return self.question_text - so this we modified int he models.py
         Also adding one more model

Now we are adding other urls also in the polls/urls.py file and its respective views in views.py file
In the url.py the path("", views.index, name="index"), here if we want to add other paths then "" should not be there and should be replaced with other then the url will become :8000/polls/other so all the urls should not be same which creates confusion for django to what to choose and show on the web page. 

Question.objects ‚Üí gives you access to all the rows in the Question table. Question.objects = the manager that lets you talk to the table.
   ‚Ä¢	Question.objects.all() ‚Üí all rows from polls_question.
	‚Ä¢	Question.objects.filter(id=1) ‚Üí only row with id=1.
	‚Ä¢	Question.objects.order_by("-pub_date") ‚Üí rows sorted by latest publish date.

output = ", ".join([q.question_text for q in latest_question_list])
here if we give 3 qstns then all are printed in list format

 so when we visit :8000/polls we see the data like 
        Your favorite color?, Best fruit?, Best movie?

=> Now as the view of the page is hardcoded i.e. it will display how the django shows we can actually change it using templates folder which need to be created inside polls when django looks for it and if not found it uses the default page.
-> polls 
     -> templates
         -> polls
             -> index.html - should be like this and write the html code in this
Now this is how it should look right so need to modify the views.py
  template = loader.get_template("polls/index.html")
    => this is just getting the template of the page and we need to pas the data later

    context = {"latest_question_list": latest_question_list}             
       here we are sending the data to the template page

    template.render(context, request)
      this will take the html file and fill the data in it and show on the web page   
* There is a shortcut for the loader and render part

* What if user entered wrong id for the question then we need to raise an error right for that 404   


models                                            Vs                                 Model
models is the module. file/package django gives                         inside models we have many classes one of them is Model
school                                                                  this is like a teacher class


We can do automation testing using tests.py file. we write the code and test it at code level with command
    python manage.py test polls
This runs the tests that are defined in tests.py file inside polls app.

=> We can add color to the page by creating a static/polls/style.css file and linking that to index.html, detail.html and whatever pages
=> we also have a django debug toolbar which works same like network tab in inspect element of browser
   pip install django-debug-toolbar
   then add it to installed apps in settings.py file and also add the middleware in the same file
   then add the url in the main urls.py file of project folder
   then run the server and see the changes on the browser


To make changes in the admin we are modifying admin.py and in settings we are proving the templates path
in other name
/opt/homebrew/Caskroom/miniconda/base/lib/python3.12/site-packages/django
now we go here and write the html or css code to change the look of the admin page




I have created the docker file same as before and created the image and container and checked in localhost:8000/polls
Now we are going to deploy this project in aws ec2 instance
1. Create an ec2 instance and connect to it using ssh
2. Now installed docker
   Written gitactions file for build and push and validate whether the workflow is successful or not
   Now actions file for deploy the docker container to ec2 instance by pulling the image and removing the container if exists
   Now once everything is working fine checking with the publicip:8000/polls

3. Now trying to back up the data from local to ec2 such that even though the instance is deleted  the data is still there
   => First connect to ec2 instance - just like we have done in nemani astrology project have the sql file and code file
   => Now move those both files to ec2 instance using scp command.
      scp -i "keypair.pem" sql and zip file ubuntu@ec2-ip-address:/home/ubuntu/

Now for the app to run we need nginx, php and db mariadb right so install them one by one
   sudo apt update
   sudo apt install nginx
   sudo apt install php-fpm php-mysql
   sudo apt install mariadb-server mariadb-client
   sudo mysql_secure_installation

   Got to mariadb and create db and user and provide all privileges
